#!/bin/bash
set -euo pipefail
IFS=$' \n\t'

export MIN_WINDOW_HEIGHT=128
export X_DIRECTION_GEOM_SLACK=64
export Y_DIRECTION_BUFFER="4 0"
ACTION_TEST=""
PIXELSHIFT=""
CENTER=""
COLUMN=""
DIR=""
SWAP=""
WINMOVE=""
MOVE=""
GAP=""
REPORT=""
RESIZE=""
SELECTED_WINDOW_ID=""

show_help() {
    echo "NAME:"
    echo "  $0 - Bash based PaperWM like thing"
    echo ""
    echo "GLOBAL OPTIONS:"
    echo "  -t TEST ARG... Builds an area spec"
    echo "  -s [+-]N Shift the screen +/- N pixels to the right and +/- M pixels to the bottom"
    echo "  -c [1/2] Centre the active window (just on screen or in centre)"
    echo "  -g Gap fix (around column)"
    echo "  -o [12] Fix this column - 1 = space proportionally, 2 = keep this window size"
    echo "  -i Supply a window id when appropriate (-o)"
    echo "  -d [hjkl] Focus in the direction"
    echo "  -w [hjkl] Swap in the direction"
    echo "  -m [hjkl] Move in the direction"
    echo "  -r [+-]N/[+-]N Resize"
    echo "  -M"
    echo "  -R"
    echo "  -h    Get (this) help"
    echo ""
    exit 0
}


while getopts "hgr:m:d:M:Rc:t:s:o:w:i:" opt; do
    case "$opt" in
        h)
            show_help
            exit 0
            ;;
        t)
            ACTION_TEST="$OPTARG"
            ;;
        s)
            PIXELSHIFT="$OPTARG"
            ;;
        r)
            RESIZE="$OPTARG"
            ;;
        i)
            SELECTED_WINDOW_ID="$OPTARG"
            ;;
        c)
            CENTER="$OPTARG"
            ;;
        o)
            COLUMN="$OPTARG"
            ;;
        g)
            GAP="1"
            ;;
        d)
            DIR="$OPTARG"
            ;;
        w)
            SWAP="$OPTARG"
            ;;
        m)
            MOVE="$OPTARG"
            ;;
        M)
            WINMOVE="$OPTARG"
            ;;
        R)
            REPORT="1"
            ;;
        *)
            # echo "INVALID FLAG"
            # exit 1
    esac
done

function xdotool_getdisplaygeometry() {
    xrandr | cat /dev/stdin | awk 'BEGIN { screen="" }
    $2 == "connected" { screen = $1 }
    $1 ~ /^[0-9]+x[0-9]+/ && $2 ~ /^[0-9\.]+\*/ { gsub(/[^0-9x]/, "", $1); gsub("x", " ", $1); printf "%s %s\n", screen, $1 }
    ' | sed 's/[^ ]\+ //' | sort -n -k 1 | tail -n 1

}
export -f xdotool_getdisplaygeometry


function window_visible() {
    # return 0 # TODO
    local GEOM_X="$1"
    local GEOM_Y="$2"
    local CUR_X="$3"
    local CUR_Y="$4"
    local CUR_W="$5"
    local CUR_H="$6"

	local CUR_XX=$(( $CUR_X + $CUR_W ))
	local CUR_YY=$(( $CUR_Y + $CUR_H ))

	local MIN_GEOM_XY=$(( 0 + $X_DIRECTION_GEOM_SLACK ))
	local MAX_GEOM_X=$(( $GEOM_X - $X_DIRECTION_GEOM_SLACK ))
	local MAX_GEOM_Y=$(( $GEOM_Y - $X_DIRECTION_GEOM_SLACK ))

    local VISIBLE=1

	if [ "$CUR_XX" -lt $MIN_GEOM_XY ] || [ "$CUR_YY" -lt $MIN_WINDOW_HEIGHT ]; then
	    VISIBLE=0
    fi
	if [ "$CUR_X" -gt $MAX_GEOM_X ] || [ "$CUR_Y" -gt $MAX_GEOM_Y ]; then
	    VISIBLE=0
    fi
    # echo "GN $MIN_GEOM_XY"
    # echo "GNXY $MAX_GEOM_X $MAX_GEOM_Y"
    # echo "X $CUR_X $CUR_W $CUR_XX"
    # echo "Y $CUR_Y $CUR_H $CUR_YY"
    # echo "V $VISIBLE"
    echo $VISIBLE
}
export -f window_visible


function xdotool_windowshift() {
    # echo "1: $1"
    # echo "2: $2"
    # echo "3: $3"
    # echo "4: $4"
    # echo "5: $5"

    local OFFSET_X_NEG=0
    local OFFSET_Y_NEG=0
    local OFFSET_X="$1"
    local OFFSET_Y="$2"
	local RE="^\-"
	if [[ "$OFFSET_X" =~ $RE ]]; then
    	OFFSET_X_NEG=1
    fi
	if [[ "$OFFSET_Y" =~ $RE ]]; then
    	OFFSET_Y_NEG=1
    fi
    OFFSET_X="$( echo $OFFSET_X | sed 's/[^0-9\+]//g')"
    OFFSET_Y="$( echo $OFFSET_Y | sed 's/[^0-9\+]//g')"

    local SPLIT=( $5 )
    local WINDOW_ID=${SPLIT[0]}
    local CUR_X=${SPLIT[1]}
    local CUR_Y=${SPLIT[2]}
    local CUR_W=${SPLIT[3]}
    local CUR_H=${SPLIT[4]}

    local GEOM_X="$3"
    local GEOM_Y="$4"

	CUR_X=$(( "$CUR_X" + "$OFFSET_X" ))
	CUR_Y=$(( "$CUR_Y" + "$OFFSET_Y" ))

	if [ "$OFFSET_X_NEG" -gt 0 ]; then
    	CUR_X=$(( "$CUR_X" - ( "$OFFSET_X" * 2 ) ))
    fi
	if [ "$OFFSET_Y_NEG" -gt 0 ]; then
    	CUR_Y=$(( "$CUR_Y" - ( "$OFFSET_Y" * 2 ) ))
	fi


    window_move "1 $GEOM_X $GEOM_Y $WINDOW_ID $CUR_X $CUR_Y $CUR_W $CUR_H"
    # if window_visible "$GEOM_X" "$GEOM_Y" "$CUR_X" "$CUR_Y" "$CUR_W" "$CUR_H"; then
    #     # xdotool windowraise "$WINDOW_ID"
    #     xprop -id "$WINDOW_ID" -f _CURTAIN_XYWH 8s -set _CURTAIN_XYWH ""
    # else
    #     xdotool windowminimize "$WINDOW_ID"
    #     xprop -id "$WINDOW_ID" -f _CURTAIN_XYWH 8s -set _CURTAIN_XYWH "$CUR_X $CUR_Y $CUR_W $CUR_H"
    # fi
}
export -f xdotool_windowshift


function xdotool_getwindowgeometry_to_details() {
    cat /dev/stdin | sed 's/^ \+//' | awk -F '[ x,]' '$1 == "Window" { i=$2 } $1 == "Position:" { x=$2; y=$3 } $1 == "Geometry:" { w=$2; h=$3 } END { print x, y, w, h }'
}
export -f xdotool_getwindowgeometry_to_details


function list_windows() {
    xdotool search --desktop "$(xdotool get_desktop)" --all .  2>/dev/null | grep '^[0-9]'
}
export -f list_windows


function xprop_details() {
    cat /dev/stdin | awk -F '=' 'NF < 2 { next } {printf("%s=", gensub(/^ *(.*[^ ])\(.*/, "\\1", "g", $1)) } $2 ~ /"/ { print gensub(/^ *"(.*)" *$/, "\\1", "g", $2); next } { print(gensub(/^ *(.*[^ ]) *$/, "\\1", "g", $2)) }'
}
export -f xprop_details


function details_value() {
    cat /dev/stdin | awk -v K="$1" -F '=' '$1 == K { print $2 }'
}
export -f details_value


function xdotool_xprop_getwindowgeometry() {
    local XPROPS="$(xprop -id $1 | xprop_details)"
    local XPROP_MINIM="$(echo "$XPROPS" | details_value _NET_WM_STATE | awk 'BEGIN { m=0 } $0 ~ /_NET_WM_STATE_HIDDEN/ { m=1 } END { print m }' )"
    local XPROP_GEOM="$(echo "$XPROPS" | details_value _CURTAIN_XYWH)"
    if [ "$XPROP_MINIM" -gt 0 ] && [ ! -z "$XPROP_GEOM" ]; then
        echo $1 $XPROP_GEOM
        return 0
    fi
    local FRAME="$(xprop -id "$1" | grep _NET_FRAME_EXTENTS | awk -F [=,] '{print gensub(/.*([0-9]+), *([0-9]+), *([0-9]+), *([0-9]+).*/, "\\1 \\2 \\3 \\4", "g", $0)}')"
    local WIN="$(xdotool getwindowgeometry "$1" | xdotool_getwindowgeometry_to_details)"
    local FRAME_LRTB=( $FRAME )
    local WIN_XYWH=( $WIN )
    local X=$(( ${WIN_XYWH[0]} - (${FRAME_LRTB[0]} * 2) ))
    local Y=$(( ${WIN_XYWH[1]} - (${FRAME_LRTB[2]} * 2) ))
    local W=$(( ${WIN_XYWH[2]} + (${FRAME_LRTB[0]} + ${FRAME_LRTB[1]}) ))
    local H=$(( ${WIN_XYWH[3]} + (${FRAME_LRTB[2]} + ${FRAME_LRTB[3]}) ))
    echo "$1 $X $Y $W $H"
}
export -f xdotool_xprop_getwindowgeometry


# function windows_in_column_slack() {
#     local CURRENT_COLUMN_WIDTH="$1"
#     local PERCENT="$2"
#     local PIXELS="$3"
#     local PER_VAL=$(( $CURRENT_COLUMN_WIDTH * (PERCENT / 100) ))
#     local PIX_VAL=$(( $CURRENT_COLUMN_WIDTH - $PIXELS ))
#     if [[ "$PER_VAL" -gt "$PIX_VAL" ]]; then
#         echo "$PER_VAL"
#         return
#     fi
#     echo "$PIX_VAL"
# }


function windows_in_column() {
    # export -f xdotool_xprop_getwindowgeometry
    # cat /dev/stdin | parallel xdotool_xprop_getwindowgeometry "$1"
    # echo "> $1, $2, $3"
    local SELECTED_WIN="$1"
    local SCREEN_TOP="$2"
    local SCREEN_HEIGHT="$3"
    local PROPORTIONAL=1
    if [ "$#" -gt 3 ]; then
        PROPORTIONAL="$4"
    fi

    cat /dev/stdin | \
        awk -v SELECTED_WIN="$SELECTED_WIN" '
            # Put the selected window at the top
            $1!=SELECTED_WIN { print NR, $0 }
            $1==SELECTED_WIN { FOUND=$0 }
            END {
                if (FOUND) {
                        print NR+1, FOUND
                }
            }
            ' | \
        sort -r | \
        sed 's/[0-9]\+ //' | \
        awk -v CENTER_OR_EDGE=1 -v SELECTED_WIN="$SELECTED_WIN" '
            BEGIN { COL_LEFT="UN"; COL_RIGHT="UN"; LEFT="UN"; ITEMS_INDEX=0; SELECTED_WIN_HEIGHT=128 }

            function slack(WIDTH, SLACK_PIXELS, SLACK_PERCENT) {
                TMP = WIDTH * (SLACK_PERCENT / 100)
                if (TMP > SLACK_PIXELS) {
                    return SLACK_PIXELS
                }
                return TMP
            }

            # Output column details then windows in column, identified by current selected window (top).
            LEFT=="UN" {
                LEFT=$2
                WIDTH=$4
                RIGHT=$2+WIDTH
                COL_LEFT=LEFT
                COL_RIGHT=RIGHT
                COL_TOP=$3
                COL_HEIGHT=0
            }
            { ADD = 0 }
            $1 == SELECTED_WIN { SELECTED_WIN_HEIGHT=$5 }
            CENTER_OR_EDGE == 0 {
                CENTER=$2 + ($4 / 2)
                if ((CENTER <= RIGHT) && (CENTER >= LEFT)) {
                    ADD = 1
                }
            }
            CENTER_OR_EDGE == 1 {
                LINE_LEFT=$2
                LINE_RIGHT=$2+$4
                INCLUDE_LEFT = LINE_LEFT + slack($4, 16, 16)
                INCLUDE_RIGHT = LINE_RIGHT - slack($4, 16, 16)
                if ((INCLUDE_LEFT < LEFT) && (INCLUDE_RIGHT < LEFT)) { next }
                if ((INCLUDE_LEFT > RIGHT) && (INCLUDE_RIGHT > RIGHT)) { next }
                ADD = 1
            }
            ADD == 1 {
                ITEMS[ITEMS_INDEX] = $0; ITEMS_INDEX = ITEMS_INDEX + 1
                if (COL_LEFT > $2) { COL_LEFT = $2 }
                if (COL_RIGHT < $2 + $4) { COL_RIGHT = $2 + $4 }
                if ($3 < COL_TOP) { COL_TOP = $3 }
                COL_HEIGHT = COL_HEIGHT + $5
            }
            END {
                print SELECTED_WIN, COL_LEFT, COL_TOP, (COL_RIGHT - COL_LEFT), COL_HEIGHT, SELECTED_WIN_HEIGHT, ITEMS_INDEX
                for (I in ITEMS) {
                    print ITEMS[I]
                }
            }' | \
        awk -v SCREEN_TOP="$SCREEN_TOP" \
            -v SCREEN_HEIGHT="$SCREEN_HEIGHT" \
            -v MIN_WINDOW_HEIGHT="$MIN_WINDOW_HEIGHT" \
            -v PROPORTIONAL="$PROPORTIONAL" '
            # Scale and force windows into the column (does make windows not overlap)

            NR == 1 {
                SELECTED_WIN = $1
                SELECTED_WIN_HEIGHT=$6
                WINDOW_COUNT=$7
                COL_LEFT = $2; COL_TOP = $3; COL_WIDTH = $4; COL_HEIGHT = $5
                MAX_WIN_HEIGHT = SCREEN_HEIGHT - int(MIN_WINDOW_HEIGHT * (WINDOW_COUNT - 1))
                if (SELECTED_WIN_HEIGHT > MAX_WIN_HEIGHT) { SELECTED_WIN_HEIGHT = MAX_WIN_HEIGHT }
                next
            }
            PROPORTIONAL != "2" {
                WIN_TOP = $3
                WIN_ACT_HEIGHT = $5
                if (WIN_ACT_HEIGHT > MAX_WIN_HEIGHT) { WIN_ACT_HEIGHT = MAX_WIN_HEIGHT }
                WIN_HEIGHT = int(SCREEN_HEIGHT / (COL_HEIGHT / WIN_ACT_HEIGHT))
                print $1, COL_LEFT, int(WIN_TOP + (WIN_HEIGHT / 2)), COL_WIDTH, WIN_HEIGHT
                next
            }
            $1 == SELECTED_WIN {
                WIN_TOP = $3
                WIN_ACT_HEIGHT = $5
                if (WIN_ACT_HEIGHT > MAX_WIN_HEIGHT) { WIN_ACT_HEIGHT = MAX_WIN_HEIGHT }
                print $1, COL_LEFT, int(WIN_TOP + ($5 / 2)), COL_WIDTH, SELECTED_WIN_HEIGHT, "S"
                next
            }
            {
                WIN_TOP = $3
                WIN_ACT_HEIGHT = $5
                COL_HEIGHT_REMAIN = SCREEN_HEIGHT - SELECTED_WIN_HEIGHT
                WIN_HEIGHT = int(COL_HEIGHT_REMAIN / (WINDOW_COUNT - 1)) # int((SCREEN_HEIGHT - SELECTED_WIN_HEIGHT) / (COL_HEIGHT_REMAIN / WIN_ACT_HEIGHT))
                print $1, COL_LEFT, int(WIN_TOP + (WIN_HEIGHT / 2)), COL_WIDTH, WIN_HEIGHT, "O",(SCREEN_HEIGHT - SELECTED_WIN_HEIGHT),"/", (COL_HEIGHT_REMAIN / WIN_ACT_HEIGHT), "=", WINDOW_COUNT
            }
            ' | \
        sort -n -k 3 | \
        awk -v SCREEN_TOP="$SCREEN_TOP" -v SCREEN_HEIGHT="$SCREEN_HEIGHT" '
            BEGIN { WIN_TOP=SCREEN_TOP }
            {
                print $1, $2, WIN_TOP, $4, $5
                WIN_TOP = WIN_TOP + $5
            }
            '
}
export -f windows_in_column

function test_windows_in_column() {
    cat /dev/stdin | windows_in_column "$1" "$2" "$3"
}


function test_xdotool_getwindowgeometry_to_details() {
    cat /dev/stdin | xdotool_getwindowgeometry_to_details
}


function test_xprop_details() {
    cat /dev/stdin | xprop_details
}


function pixelshift() {
    export -f xdotool_getwindowgeometry_to_details
    export -f xdotool_xprop_getwindowgeometry
    export -f xdotool_windowshift
    export -f xdotool_getdisplaygeometry
    export -f window_visible
    export -f details_value
    export -f xprop_details
    export -f window_move
    SHIFT_X="$1"
    SHIFT_Y="$2"
    list_windows | parallel xdotool_xprop_getwindowgeometry {} '|' parallel xdotool_windowshift "$SHIFT_X" "$SHIFT_Y" $(xdotool_getdisplaygeometry)
}
export -f pixelshift


function window_move_calc() {
    local SETTINGS="$1"
    local COMPOSITOR="$2"
    local POSITION="$3"
    local WINDOW_DETAILS="$4"
    local FRAME_DETAILS="$5"

    local SETTING=""
    local USETTING=""
    local FRDET=""

    local V="$(printf "%s" "$WINDOW_DETAILS" | details_value "$POSITION")"
    local SETTING_GETTER="$POSITION"
    if [ "$COMPOSITOR" -gt 0 ]; then
        SETTING_GETTER="${SETTING_GETTER}C"
    fi
    SETTINGS="$(printf "%s" "$SETTINGS" | details_value "$SETTING_GETTER")"
    while [ ! -z "$SETTINGS" ]; do
        SETTING=${SETTINGS:0:1}
        USETTING=${SETTING^}
        SETTINGS=${SETTINGS:1}
        FRDET="$(printf "%s" "$FRAME_DETAILS" | details_value "$USETTING")"
        # echo "FRAME_DETAILS=$FRAME_DETAILS V=$V FD=$FD USETTING="$USETTING""
        if [[ "$SETTING" == "$USETTING" ]]; then
            V=$(( $V + $FRDET ))
        else
            V=$(( $V - $FRDET ))
        fi
    done

    echo "$V"
}
export -f window_move_calc


function window_move() {
    local SPLIT=( $@ )
    local MODE=${SPLIT[0]}
    local GEOM_X=${SPLIT[1]}
    local GEOM_Y=${SPLIT[2]}
    local WINDOW_ID=${SPLIT[3]}
    local X=${SPLIT[4]}
    local Y=${SPLIT[5]}
    local W=${SPLIT[6]}
    local H=${SPLIT[7]}

    VISIBLE="$(window_visible "$GEOM_X" "$GEOM_Y" "$X" "$Y" "$W" "$H")"

    local XPROPS="$(xprop -id $WINDOW_ID | xprop_details)"
    local XPROPS_FRAME="$(echo "$XPROPS" | details_value _NET_FRAME_EXTENTS | awk -F [=,] ' { print gensub(/.*([0-9]+), *([0-9]+), *([0-9]+), *([0-9]+).*/, "\\1 \\2 \\3 \\4", "g", $0) }')"

    # echo "XPROPS: $XPROPS"
    # echo "XPROPS_FRAME: $XPROPS_FRAME"
    local FRAME_LRTB=( $XPROPS_FRAME )
    FRAME_OFFSET_SETTINGS="$(echo 'X=;Y=;W=lr;H=tb;XC=;YC=;WC=lr;HC=tb' | sed 's/;/\n/g')"
    # FRAME_OFFSET_SETTINGS="$(echo 'X=;Y=;W=lr;H=tb;XC=;YC=;WC=lr;HC=tb' | sed 's/;/\n/g')"
    WINDOW_DETAILS="$( echo "X=$X;Y=$Y;W=$W;H=$H" | sed 's/;/\n/g')"
    FRAME_DETAILS="$( echo "L=${FRAME_LRTB[0]};R=${FRAME_LRTB[1]};T=${FRAME_LRTB[2]};B=${FRAME_LRTB[3]}" | sed 's/;/\n/g')"
    local IS_UNDER_COMPOSITOR=0
    local XPROPS_COMPSITOR="$(echo "$XPROPS" | details_value _NET_WM_BYPASS_COMPOSITOR)"
    if [ "$XPROPS_COMPSITOR" == "2" ]; then
        IS_UNDER_COMPOSITOR=1
    fi
    X="$(window_move_calc "$FRAME_OFFSET_SETTINGS" "$IS_UNDER_COMPOSITOR" "X" "$WINDOW_DETAILS" "$FRAME_DETAILS"  )"
    Y="$(window_move_calc "$FRAME_OFFSET_SETTINGS" "$IS_UNDER_COMPOSITOR" "Y" "$WINDOW_DETAILS" "$FRAME_DETAILS"  )"
    W="$(window_move_calc "$FRAME_OFFSET_SETTINGS" "$IS_UNDER_COMPOSITOR" "W" "$WINDOW_DETAILS" "$FRAME_DETAILS"  )"
    H="$(window_move_calc "$FRAME_OFFSET_SETTINGS" "$IS_UNDER_COMPOSITOR" "H" "$WINDOW_DETAILS" "$FRAME_DETAILS"  )"

    # echo "> X=$X;Y=$Y;W=$W;H=$H" >> /tmp/curtain
    # echo ">>" $WINDOW_ID $MODE $X $Y $W $H

    # X=$(( ${X} + ${FRAME_LRTB[0]} ))
    # Y=$(( ${Y} + ${FRAME_LRTB[2]} ))
    # W=$(( ${W} - (${FRAME_LRTB[0]} + ${FRAME_LRTB[1]}) ))
    # H=$(( ${H} - (${FRAME_LRTB[2]} + ${FRAME_LRTB[3]}) ))
    # if [ "$XPROPS_COMPSITOR" == "2" ]; then
    #     X=$(( $X - ${FRAME_LRTB[0]} ))
    #     Y=$(( $Y - ${FRAME_LRTB[2]} ))
    #     printf "%s" ""
    # fi
    if [ "$VISIBLE" -gt 0 ]; then
        if [ "$MODE" -eq 2 ] || [ "$MODE" -eq 3 ]; then
            xdotool windowsize "$WINDOW_ID" "$W" "$H"
        fi
        if [ "$MODE" -eq 1 ] || [ "$MODE" -eq 3 ]; then
            xdotool windowmove "$WINDOW_ID" "$X" "$Y"
        fi
        local WINDOW_IS_MINIMIZED="$(echo "$XPROPS" | details_value _NET_WM_STATE | awk 'BEGIN { m=0 } $0 ~ /_NET_WM_STATE_HIDDEN/ { m=1 } END { print m }' )"
        if [ "$WINDOW_IS_MINIMIZED" -gt 0 ]; then
            xdotool windowactivate "$WINDOW_ID"
        fi
        xprop -id "$WINDOW_ID" -f _CURTAIN_XYWH 8s -set _CURTAIN_XYWH ""
        # xdotool windowactivate "$WINDOW_ID"
    else
        xdotool windowminimize "$WINDOW_ID"
        # TODO: Do setting respect mode perhaps
        xprop -id "$WINDOW_ID" -f _CURTAIN_XYWH 8s -set _CURTAIN_XYWH "$X $Y $W $H"
    fi

}
export -f window_move


function window_activate() {
    local DISP_GEOM="$1"
    local TARGET_WINDOW="$2"

    SHIFT="$( echo "$DISP_GEOM $TARGET_WINDOW" | awk '
        $4 < 0 { print 0 - $4; next }
        ($4 + $6) > $1 { print "-" ($4 + $6) - $1 }
        ' )"
    if [ "$SHIFT" != "0" ]; then
        $0 -s "$SHIFT"
    fi
    if [ ! -z "$TARGET_WINDOW" ]; then
        xdotool windowactivate "$(echo "$TARGET_WINDOW" | sed 's/ .*//')"
    fi

}
export -f window_activate

function win_in_dir() {
    local DIR="$1"
    export -f details_value
    export -f window_visible
    export -f window_move_calc
    export -f window_move
    export -f xprop_details
    export -f xdotool_xprop_getwindowgeometry
    export -f xdotool_getwindowgeometry_to_details
    DISP_GEOM="$(xdotool_getdisplaygeometry)"
    S_DISP_HEIGHT="$(echo "$DISP_GEOM" | sed 's/.* //')"
    Y_MIN="$(echo "$Y_DIRECTION_BUFFER" | sed 's/ .*//')"
    Y_MAX="$(echo "$Y_DIRECTION_BUFFER" | sed 's/.* //')"
    Y_HEIGHT=$(( $S_DISP_HEIGHT - ($Y_MIN + $Y_MAX)))
    ACTIVE_WINDOW="$(xdotool getactivewindow)"
    WINDOWS="$( list_windows | parallel xdotool_xprop_getwindowgeometry {} )"
    COL_WINS="$( echo "$WINDOWS" | windows_in_column "$ACTIVE_WINDOW" $Y_MIN $Y_HEIGHT)"
    if [ "$DIR" == 'j' ] || [ "$DIR" == 'k' ]; then
        VERT="$(printf "%s" "$COL_WINS" | awk -v ACTIVE="$ACTIVE_WINDOW" 'BEGIN { PREV="_"; NEXT="_"; WAS=0 }
            $1 == ACTIVE { WAS = 1; next }
            WAS == 0 { PREV=$0 }
            WAS == 1 {
                NEXT = $0
                WAS = 2
            }
            END { print PREV "/" NEXT }
            ')"
        if [ "$DIR" == "j" ]; then
            echo "$VERT" | sed 's^.*/^^'
            return
        fi
        echo "$VERT" | sed 's^/.*^^'
        return
    else
        ACT_MID="$(printf "%s" "$WINDOWS" | awk -v W="$ACTIVE_WINDOW" 'W==$1 { print int($2 + ($4 / 2)), int($3 + ($5 / 2)) }')"
        ACT_MID_X="$( echo "$ACT_MID" | sed 's/ .*//')"
        ACT_MID_Y="$( echo "$ACT_MID" | sed 's/.* //')"
        TARGET_WINDOW="$(
            printf "%s\n%s" "$(echo "$COL_WINS" | sed 's/^/ACTCOL /')" "$WINDOWS" \ |
                awk -v DIR="$DIR" -v ACT_MID_X="$ACT_MID_X" -v ACT_MID_Y="$ACT_MID_Y" 'BEGIN {ARLEN=0; DST=999999; WIN=""}

                    function abs(v) {return v < 0 ? -v : v}

                    # Keep a note of items in current column
                    $1 == "ACTCOL" { AR[ARLEN++] = $2; next }

                    # Remove items in current column
                    {
                        for (i=0; i<ARLEN; i++) {
                            if (AR[i] == $1) {
                                next
                            }
                        }
                    }

                    # Remove windows that are in the wrong direction
                    DIR=="h" && ($2 + $4) > ACT_MID_X { next }
                    DIR=="l" && $2 < ACT_MID_X { next }

                    {
                        CUR_MID_X = int($2 + ($4 / 2));
                        CUR_MID_Y = int($3 + ($5 / 2));
                        X_DIST = abs(ACT_MID_X - CUR_MID_X);
                        Y_DIST = abs(ACT_MID_Y - CUR_MID_Y);
                        CUR_DIST = sqrt((X_DIST * X_DIST) + (Y_DIST * Y_DIST));
                        # print "WIN: ", $1
                        if (CUR_DIST < DST) {
                            # print "CUR_MID_X=", CUR_MID_X;
                            # print "CUR_MID_Y=", CUR_MID_Y;
                            # print "ACT_MID_X=", ACT_MID_X;
                            # print "ACT_MID_Y=", ACT_MID_Y;
                            # print "CUR_DIST=", CUR_DIST;
                            DST = CUR_DIST;
                            WIN = $0
                        }
                    }

                    END {
                        if (WIN != "") {
                            print WIN
                        }
                    }
                    '
            )"
        if [ ! -z "$TARGET_WINDOW" ]; then
            printf "%s\n" "$TARGET_WINDOW"
        fi
    fi
}
export -f win_in_dir


if [ ! -z "$ACTION_TEST" ]; then
    shift $(( OPTIND - 1 ))
    test_"$ACTION_TEST" $@
    exit
fi


if [ ! -z "$PIXELSHIFT" ]; then
    ACTIVE_WINDOW="$(xdotool getactivewindow)"
    shift 1
    pixelshift "$PIXELSHIFT" 0
    xdotool windowactivate "$ACTIVE_WINDOW"
    exit
fi


if [ ! -z "$CENTER" ]; then
    export -f window_move_calc
    S_DISP_GEOM="$(xdotool_getdisplaygeometry)"
    ACTIVE_WINDOW_ID="$(xdotool getactivewindow)"
    S_WIN_GEOM="$(xdotool_xprop_getwindowgeometry "$ACTIVE_WINDOW_ID")"
    if [ "$CENTER" -eq "1" ]; then
        window_activate "$S_DISP_GEOM" "$S_WIN_GEOM"
        exit
    fi
    shift 1
    # xdotool_xprop_getwindowgeometry "$ACTIVE_WINDOW_ID"
    # S_WIN_GEOM="$(xdotool_xprop_getwindowgeometry "$(xdotool getactivewindow)")"
    # S_DISP_GEOM="$(xdotool_getdisplaygeometry)"
    WIN_GEOM=( $S_WIN_GEOM )
    DISP_GEOM=( $S_DISP_GEOM )
    XSHIFT=$(( (${DISP_GEOM[0]} / 2) - (${WIN_GEOM[1]} + (${WIN_GEOM[3]} / 2))  ))
    ACTIVE_WINDOW="$(xdotool getactivewindow)"
    pixelshift "$XSHIFT" 0
    xdotool windowactivate "$ACTIVE_WINDOW"
    exit
fi

if [ ! -z "$COLUMN" ]; then
    export -f details_value
    export -f window_visible
    export -f window_move_calc
    export -f window_move
    export -f xprop_details
    export -f xdotool_xprop_getwindowgeometry
    export -f xdotool_getwindowgeometry_to_details
    ACTIVE_WINDOW="$(xdotool getactivewindow)"
    WINDOW_ID="$(xdotool getactivewindow)"
    DISP_GEOM="$(xdotool_getdisplaygeometry)"
    S_DISP_HEIGHT="$(echo "$DISP_GEOM" | sed 's/.* //')"
    Y_MIN="$(echo "$Y_DIRECTION_BUFFER" | sed 's/ .*//')"
    Y_MAX="$(echo "$Y_DIRECTION_BUFFER" | sed 's/.* //')"
    Y_HEIGHT=$(( $S_DISP_HEIGHT - ($Y_MIN + $Y_MAX)))
    if [ ! -z "$SELECTED_WINDOW_ID" ]; then
        WINDOW_ID="$SELECTED_WINDOW_ID"
    fi
    list_windows | parallel xdotool_xprop_getwindowgeometry {} | windows_in_column "$WINDOW_ID" $Y_MIN $Y_HEIGHT $COLUMN | parallel window_move "3 $DISP_GEOM {}"
    xdotool windowactivate "$ACTIVE_WINDOW"
    exit
fi


if [ ! -z "$DIR" ]; then
    export -f window_move_calc
    DISP_GEOM="$(xdotool_getdisplaygeometry)"
    S_DISP_WIDTH="$(echo "$DISP_GEOM" | sed 's/ .*//')"
    TARGET_WINDOW="$( win_in_dir "$DIR" )"
    window_activate "$DISP_GEOM" "$TARGET_WINDOW"
    # LEFT="$( echo "$TARGET_WINDOW" | awk '{ print $2 }' )"
    # SHIFT="$( echo "$DISP_GEOM $TARGET_WINDOW" | awk '
    #     $4 < 0 { print 0 - $4; next }
    #     ($4 + $6) > $1 { print "-" ($4 + $6) - $1 }
    #     ' )"
    # if [ "$SHIFT" != "0" ]; then
    #     $0 -s "$SHIFT"
    # fi
    # if [ ! -z "$TARGET_WINDOW" ]; then
    #     xdotool windowactivate "$(echo "$TARGET_WINDOW" | sed 's/ .*//')"
    # fi
    exit
fi


if [ ! -z "$SWAP" ]; then
    export -f window_visible
    export -f window_move_calc
    export -f window_move
    export -f details_value
    export -f xprop_details
    DISP_GEOM="$(xdotool_getdisplaygeometry)"
    ACTIVE_WIN="$(xdotool_xprop_getwindowgeometry "$(xdotool getactivewindow)")"
    TARGET_WINDOW="$( win_in_dir "$SWAP" )"
    MOVES="$(
        printf "%s\n%s\n" "$ACTIVE_WIN" "$TARGET_WINDOW" | \
            awk '
                BEGIN { FIRST_ID=""; SECOND_ID=""; FIRST=""; SECOND=""; }
                FIRST_ID != "" { SECOND_ID = $1; SECOND = $2 " " $3 " " $4 " " $5 }
                FIRST == "" { FIRST_ID = $1; FIRST = $2 " " $3 " " $4 " " $5 }
                END {
                    print SECOND_ID, FIRST
                    print FIRST_ID, SECOND
                }
                ' | \
            sed 's/^//'
        )"

    printf "%s\n" "$MOVES" | sed 's/^/3 '"$DISP_GEOM /" | parallel window_move {}
    exit
fi


if [ ! -z "$MOVE" ]; then

    if [ "$MOVE" == "j" ] || [ "$MOVE" == "k" ]; then
        "$0" -w "$MOVE"
        exit
    fi

    export -f details_value
    export -f window_visible
    export -f window_move_calc
    export -f window_move
    export -f xprop_details
    export -f xdotool_xprop_getwindowgeometry
    export -f xdotool_getwindowgeometry_to_details

    DISP_GEOM="$(xdotool_getdisplaygeometry)"
    S_DISP_HEIGHT="$(echo "$DISP_GEOM" | sed 's/.* //')"
    Y_MIN="$(echo "$Y_DIRECTION_BUFFER" | sed 's/ .*//')"
    Y_MAX="$(echo "$Y_DIRECTION_BUFFER" | sed 's/.* //')"
    Y_HEIGHT=$(( $S_DISP_HEIGHT - ($Y_MIN + $Y_MAX)))

    ACTIVE_WINDOW="$(xdotool getactivewindow)"
    WINDOWS="$( list_windows | parallel xdotool_xprop_getwindowgeometry {} )"
    COL_WINS="$( echo "$WINDOWS" | windows_in_column "$ACTIVE_WINDOW" $Y_MIN $Y_HEIGHT)"
    WIN_IN_COL_COUNT="$(echo "$COL_WINS" | wc -l)"

    if [ "$WIN_IN_COL_COUNT" -gt 1 ]; then
        MOVE_X_FROM="$( echo "$COL_WINS" | awk '{ print $2 }' | tail -n 1 )"
        MOVE_DISTANCE="$( echo "$COL_WINS" | head -n 1 | awk '{ print $4 }' )"
        echo $MOVE_DISTANCE

        NEGATE=""
        if [ "$MOVE" == "l" ]; then
            NEGATE="-"
        fi
        MOVE_WINDOWS="$(
            echo "$WINDOWS" | \
            awk -v MOVE_X_FROM="$MOVE_X_FROM" \
                -v MOVE_DISTANCE="${NEGATE}$MOVE_DISTANCE" \
                -v Y_MIN="$Y_MIN" \
                -v Y_HEIGHT="$Y_HEIGHT" \
                -v ACTIVE_WINDOW="$ACTIVE_WINDOW" \
                '
                    $1 == ACTIVE_WINDOW { print $1, $2, Y_MIN, $4, Y_HEIGHT; next }
                    ($2 >= MOVE_X_FROM) && (MOVE_DISTANCE > 0) { print $1, $2 + MOVE_DISTANCE, $3, $4, $5; next }
                    ($2 <= MOVE_X_FROM) && (MOVE_DISTANCE < 0) { print $1, $2 + MOVE_DISTANCE, $3, $4, $5; next }
                ' | \
            sed 's/^/3 '"$DISP_GEOM /"
            )"
        echo "ACTIVE_WINDOW: $ACTIVE_WINDOW"
        echo "OLD_WINDOWS: $WINDOWS"
        echo "MOVE_WINDOWS: $MOVE_WINDOWS"
        echo "CW: $COL_WINS"
        # echo ""
        printf "%s" "$MOVE_WINDOWS" | parallel window_move {}
        MOVED_FROM_WINDOW_ID="$( echo "$COL_WINS" | awk -v ACTIVE_WINDOW="$ACTIVE_WINDOW" '$1 != ACTIVE_WINDOW { print $1 }' )"
        echo "MOVED_FROM_WINDOW_ID: $MOVED_FROM_WINDOW_ID"
        printf "%s\n"  "$MOVED_FROM_WINDOW_ID" | parallel -j 1 $0 -o 1 -i {}
        exit
    else
        TARGET_WINDOW="$( win_in_dir "$MOVE" )"
        echo "$TARGET_WINDOW"
        echo $ACTIVE_WINDOW
        MOVE_TO_COL_WINS="$( echo "$WINDOWS" | windows_in_column "$(echo "$TARGET_WINDOW" | sed 's/ .*//')" $Y_MIN $Y_HEIGHT)"
        echo "$MOVE_TO_COL_WINS"
        MOVE_TO_COL_COUNT="$( echo "$MOVE_TO_COL_WINS" | wc -l )"
        echo $MOVE_TO_COL_COUNT
        echo $Y_HEIGHT
        echo "="
        OLD_WINDOW_MOVE="$(
            printf "%s" "$MOVE_TO_COL_WINS" | awk \
                -v WINDOW_COUNT="$MOVE_TO_COL_COUNT" \
                -v DISP_GEOM="$DISP_GEOM" '
                    BEGIN { MULT = WINDOW_COUNT / (WINDOW_COUNT + 1) }
                    {
                        # print $0
                        print 3, DISP_GEOM, $1, $2, int($3 * MULT), $4, int($5 * MULT)
                    }
                ' )"
        OLD_WINDOW_MOVE_NEW_Y="$(
            printf "%s" "$OLD_WINDOW_MOVE" | awk '
                BEGIN { Y=0; H=0 }
                $6 > Y { Y = $6; H = $8 }
                END { print Y + H + 1 }' )"
        OLD_WINDOW_MOVE_NEW_H=$(( $Y_HEIGHT - $OLD_WINDOW_MOVE_NEW_Y ))
        CURRENT_WINDOW_NEW_POSITION="$(
            echo "$OLD_WINDOW_MOVE" | \
                head -n 1 | \
                awk -v ACTIVE_WINDOW="$ACTIVE_WINDOW" \
                    -v Y="$OLD_WINDOW_MOVE_NEW_Y" \
                    -v H="$OLD_WINDOW_MOVE_NEW_H" '
                        { print $1, $2, $3, ACTIVE_WINDOW, $5, Y, $7, H }'
            )"
        printf "%s\n%s\n" "$OLD_WINDOW_MOVE" "$CURRENT_WINDOW_NEW_POSITION" | parallel window_move {}

        # 52428802 1169 0 1466 1541
        # 138412039 1169 1541 1466 616

    fi
    exit
fi


if [ ! -z "$WINMOVE" ]; then
    XX="$(echo "$WINMOVE" | awk -F 'x' '{ print $1 }')"
    YY="$(echo "$WINMOVE" | awk -F 'x' '{ print $2 }')"
    WW="$(echo "$WINMOVE" | awk -F 'x' '{ print $3 }')"
    HH="$(echo "$WINMOVE" | awk -F 'x' '{ print $4 }')"
    DISP_GEOM="$(xdotool_getdisplaygeometry)"
    WINDOW_ID="$(xdotool getactivewindow)"
    if [ ! -z "$SELECTED_WINDOW_ID" ]; then
        WINDOW_ID="$SELECTED_WINDOW_ID"
    fi
    PARAM="$(echo "$WINDOW_ID $XX $YY $WW $HH" | sed 's/^/3 '"$DISP_GEOM /")"
    window_move "$PARAM"
    exit
fi


if [ ! -z "$REPORT" ]; then
    WIN="$(xdotool getactivewindow)"
    xdotool_xprop_getwindowgeometry "$WIN"
    exit
fi


if [ ! -z "$RESIZE" ]; then
    DISP_GEOM="$(xdotool_getdisplaygeometry)"
    S_DISP_HEIGHT="$(echo "$DISP_GEOM" | sed 's/.* //')"
    Y_MIN="$(echo "$Y_DIRECTION_BUFFER" | sed 's/ .*//')"
    Y_MAX="$(echo "$Y_DIRECTION_BUFFER" | sed 's/.* //')"
    Y_HEIGHT=$(( $S_DISP_HEIGHT - ($Y_MIN + $Y_MAX)))
    ACTIVE_WINDOW="$(xdotool getactivewindow)"
    WINDOWS="$( list_windows | parallel xdotool_xprop_getwindowgeometry {})"
    COL_WINS="$( echo "$WINDOWS" | windows_in_column "$ACTIVE_WINDOW" $Y_MIN $Y_HEIGHT )"
    COL_WIN_COUNT="$( echo "$COL_WINS" | wc -l )"
    printf "%s\n%s" "$( echo "$COL_WINS" | sort -n -k 3 | sed 's/^/C /' )" "$( echo "$WINDOWS" | sed 's/^/W /' )" | \
        awk \
            -v VERT="$(echo "$RESIZE" | sed 'sX.*/XX')" \
            -v HORIZ="$(echo "$RESIZE" | sed 'sX/.*XX')" \
            -v ACTIVE_WINDOW="$ACTIVE_WINDOW" '
            BEGIN {COL_LEN=0; POST_WIN_ID=""}

            function in_array(ar, v) {
                for (i in ar) {
                    if (ar[i] == v) {
                        return i + 1
                    }
                }
                return 0
            }

            $1 == "C" {
                COLS[COL_LEN++] = $2
                if ((ACTIVE_WINDOW == $2) || (POST_WIN_ID== ACTIVE_WINDOW)) {
                    POST_WIN_ID=$2
                    POST_WIN_HEIGHT=$5
                }
                if (POST_WIN_ID== "") {
                    PRE_WIN_ID=$2
                    PRE_WIN_HEIGHT=$5
                }
                LEFT = $3
                PRE_WIN_HEIGHT_REMOVE = 0
                POST_WIN_HEIGHT_REMOVE = 0
                if (PRE_WIN_HEIGHT - MIN_WINDOW_HEIGHT > VERT) { PRE_WIN_HEIGHT_REMOVE = VERT }
                if (POST_WIN_HEIGHT - MIN_WINDOW_HEIGHT > VERT) { POST_WIN_HEIGHT_REMOVE = VERT }
            }

            ($1 == "W") && (POST_WIN_ID== ACTIVE_WINDOW) {
                POST_WIN_ID= ""
                POST_WIN_HEIGHT_REMOVE = 0
            }
            ($1 == "W") && (PRE_WIN_ID == ACTIVE_WINDOW) {
                PRE_WIN_ID = ""
                PRE_WIN_HEIGHT_REMOVE = 0
            }
            {
                # print "N/P: ", PRE_WIN_ID, "(",PRE_WIN_HEIGHT_REMOVE,")/", POST_WIN_ID, "(",POST_WIN_HEIGHT_REMOVE,")"
            }
            ($1 == "W") && (in_array(COLS, $2)) && ($2 == PRE_WIN_ID) {
                print $2, $3 - HORIZ, $4, $5 + (HORIZ * 2), $6 - PRE_WIN_HEIGHT_REMOVE
                next
            }
            ($1 == "W") && (in_array(COLS, $2)) && ($2 == POST_WIN_ID) {
                print $2, $3 - HORIZ, $4 + POST_WIN_HEIGHT_REMOVE, $5 + (HORIZ * 2), $6 - POST_WIN_HEIGHT_REMOVE
                next
            }
            ($1 == "W") && (in_array(COLS, $2)) && ($2 == ACTIVE_WINDOW) {
                print $2, $3 - HORIZ, $4 - PRE_WIN_HEIGHT_REMOVE, $5 + (HORIZ * 2), $6 + PRE_WIN_HEIGHT_REMOVE + POST_WIN_HEIGHT_REMOVE
                next
            }
            ($1 == "W") && (in_array(COLS, $2)) {
                print $2, $3 - HORIZ, $4, $5 + (HORIZ * 2), $6
                next
            }
            ($1 == "W") && (!in_array(COLS, $2)) && ($3 < LEFT) {
                print $2, $3 - HORIZ, $4, $5, $6
                next
            }
            ($1 == "W") && (!in_array(COLS, $2)) && ($3 > LEFT) {
                print $2, $3 + HORIZ, $4, $5, $6
                next
            }
            ' | \
        sed "s/^/3 $DISP_GEOM /" | \
        cat | parallel window_move {}
    exit
fi


if [ ! -z "$GAP" ]; then
    DISP_GEOM="$(xdotool_getdisplaygeometry)"
    S_DISP_HEIGHT="$(echo "$DISP_GEOM" | sed 's/.* //')"
    Y_MIN="$(echo "$Y_DIRECTION_BUFFER" | sed 's/ .*//')"
    Y_MAX="$(echo "$Y_DIRECTION_BUFFER" | sed 's/.* //')"
    Y_HEIGHT=$(( $S_DISP_HEIGHT - ($Y_MIN + $Y_MAX)))
    ACTIVE_WINDOW="$(xdotool getactivewindow)"
    WINDOWS="$( list_windows | parallel xdotool_xprop_getwindowgeometry {} )"
    COL_WINS="$( echo "$WINDOWS" | windows_in_column "$ACTIVE_WINDOW" $Y_MIN $Y_HEIGHT)"

    COL_LEFT_RIGHT="$(printf "%s\n" "$COL_WINS" | head -n1 | awk '
        BEGIN { WR = 1; WL = 999999 }
        { if ($2 + $4 > WR) { WR = $2 + $4 } if (WL > $2) { WL = $2 } }
        END { print WL, WR }')"

    COL_LEFT="$(echo "$COL_LEFT_RIGHT" | sed 's/ .*//')"
    COL_RIGHT="$(echo "$COL_LEFT_RIGHT" | sed 's/.* //')"

    GAP_LEFT_RIGHT="$(printf "%s\n" "$WINDOWS" | awk -v COL_LEFT="$COL_LEFT" -v COL_RIGHT="$COL_RIGHT" '
        BEGIN { MOST_LEFT=0; MOST_RIGHT=999999 }
        (($2 + $4 > MOST_LEFT) && ($2 + $4 < COL_LEFT)) {
                MOST_LEFT = $2 + $4
        }
        (($2 < MOST_RIGHT) && ($2 > COL_RIGHT)) {
                MOST_RIGHT = $2
        }
        END { print COL_LEFT - MOST_LEFT, MOST_RIGHT - COL_RIGHT }')"

    GAP_LEFT="$(echo "$GAP_LEFT_RIGHT" | sed 's/ .*//')"
    GAP_RIGHT="$(echo "$GAP_LEFT_RIGHT" | sed 's/.* //')"

    MOVES="$(
        printf "%s\n" "$WINDOWS" | awk -v GAP_LEFT="$GAP_LEFT" -v GAP_RIGHT="$GAP_RIGHT" -v COL_LEFT="$COL_LEFT" -v COL_RIGHT="$COL_RIGHT" '
            $2 + $4 < COL_LEFT {
                print $1, ($2 + GAP_LEFT) - 1, $3, $4, $5
            }
            $2 > COL_RIGHT {
                print $1, ($2 - GAP_RIGHT) + 1, $3, $4, $5
            }'
        )"

    printf "%s\n" "$MOVES" | sed 's/^/1 '"$DISP_GEOM /" | parallel window_move {}


    #window_move "1 $GEOM_X $GEOM_Y $WINDOW_ID $CUR_X $CUR_Y $CUR_W $CUR_H"
    xdotool windowactivate "$ACTIVE_WINDOW"
    exit
fi
