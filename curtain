#!/bin/bash
set -euo pipefail
IFS=$' \n\t'

export X_DIRECTION_GEOM_SLACK=256
export Y_DIRECTION_BUFFER="0 2"
ACTION_TEST=""
PIXELSHIFT=""
CENTER=""
COLUMN=""
DIR=""
SWAP=""
WINMOVE=""
MOVE=""
GAP=""
REPORT=""
SELECTED_WINDOW_ID=""

show_help() {
    echo "NAME:"
    echo "  $0 - Bash based PaperWM like thing"
    echo ""
    echo "GLOBAL OPTIONS:"
    echo "  -t TEST ARG... Builds an area spec"
    echo "  -s [+-]N [+-]M Shift the screen +/- N pixels to the right and +/- M pixels to the bottom"
    echo "  -c Centre the active window"
    echo "  -g Gap fix (around column)"
    echo "  -o Fix this column"
    echo "  -i Supply a window id when appropriate (-o)"
    echo "  -d [hjkl] Focus in the direction"
    echo "  -w [hjkl] Swap in the direction"
    echo "  -m [hjkl] Move in the direction"
    echo "  -M"
    echo "  -R"
    echo "  -h    Get (this) help"
    echo ""
    exit 0
}


while getopts "hgm:d:M:Rct:s:ow:i:" opt; do
    case "$opt" in
        h)
            show_help
            exit 0
            ;;
        t)
            ACTION_TEST="$OPTARG"
            ;;
        s)
            PIXELSHIFT="$OPTARG"
            ;;
        i)
            SELECTED_WINDOW_ID="$OPTARG"
            ;;
        c)
            CENTER="1"
            ;;
        o)
            COLUMN="1"
            ;;
        g)
            GAP="1"
            ;;
        d)
            DIR="$OPTARG"
            ;;
        w)
            SWAP="$OPTARG"
            ;;
        m)
            MOVE="$OPTARG"
            ;;
        M)
            WINMOVE="$OPTARG"
            ;;
        R)
            REPORT="1"
            ;;
        *)
            # echo "INVALID FLAG"
            # exit 1
    esac
done


function build_spec() {
    echo "$1 _ $2 $3 $4 $5" | awk '{ print $1, "L:" $3, "T:" $4, "W:" $5, "H:" $6, "R:" ($3+$5), "B:" ($4+$6), "M:" int($3+($5/2)), "N:" int($4+($6/2)) }'
}


function identify_screen() {
    cat /dev/stdin | awk 'BEGIN { screen="" }
    $2 == "connected" { screen = $1 }
    $1 ~ /^[0-9]+x[0-9]+/ && $2 ~ /^[0-9\.]+\*/ { gsub(/[^0-9x]/, "", $1); gsub("x", " ", $1); printf "%s %s\n", screen, $1 }
    '
}

function xdotool_getdisplaygeometry() {
    xdotool getdisplaygeometry
}


function window_visible() {
    local GEOM_X="$1"
    local GEOM_Y="$2"
    local CUR_X="$3"
    local CUR_Y="$4"
    local CUR_W="$5"
    local CUR_H="$6"

	local CUR_XX=$(( $CUR_X + $CUR_W ))
	local CUR_YY=$(( $CUR_Y + $CUR_H ))

	local MIN_GEOM_XY=$(( 0 + $X_DIRECTION_GEOM_SLACK ))
	local MAX_GEOM_X=$(( $GEOM_X - $X_DIRECTION_GEOM_SLACK ))
	local MAX_GEOM_Y=$(( $GEOM_Y - $X_DIRECTION_GEOM_SLACK ))

    local INVISIBLE=0

	if [ "$CUR_XX" -lt $MIN_GEOM_XY ] || [ "$CUR_YY" -lt $MIN_GEOM_XY ]; then
	    INVISIBLE=1
    fi
	if [ "$CUR_X" -gt $MAX_GEOM_X ] || [ "$CUR_Y" -gt $MAX_GEOM_Y ]; then
	    INVISIBLE=1
    fi
    # echo "GN $MIN_GEOM_XY"
    # echo "GNXY $MAX_GEOM_X $MAX_GEOM_Y"
    # echo "X $CUR_X $CUR_W $CUR_XX"
    # echo "Y $CUR_Y $CUR_H $CUR_YY"
    # echo "INV $INVISIBLE"
    return $INVISIBLE
}


function xdotool_windowshift() {
    # echo "1: $1"
    # echo "2: $2"
    # echo "3: $3"
    # echo "4: $4"
    # echo "5: $5"

    local OFFSET_X_NEG=0
    local OFFSET_Y_NEG=0
    local OFFSET_X="$1"
    local OFFSET_Y="$2"
	local RE="^\-"
	if [[ "$OFFSET_X" =~ $RE ]]; then
    	OFFSET_X_NEG=1
    fi
	if [[ "$OFFSET_Y" =~ $RE ]]; then
    	OFFSET_Y_NEG=1
    fi
    OFFSET_X="$( echo $OFFSET_X | sed 's/[^0-9\+]//g')"
    OFFSET_Y="$( echo $OFFSET_Y | sed 's/[^0-9\+]//g')"

    local SPLIT=( $5 )
    local WINDOW_ID=${SPLIT[0]}
    local CUR_X=${SPLIT[1]}
    local CUR_Y=${SPLIT[2]}
    local CUR_W=${SPLIT[3]}
    local CUR_H=${SPLIT[4]}

    local GEOM_X="$3"
    local GEOM_Y="$4"

	CUR_X=$(( "$CUR_X" + "$OFFSET_X" ))
	CUR_Y=$(( "$CUR_Y" + "$OFFSET_Y" ))

	if [ "$OFFSET_X_NEG" -gt 0 ]; then
    	CUR_X=$(( "$CUR_X" - ( "$OFFSET_X" * 2 ) ))
    fi
	if [ "$OFFSET_Y_NEG" -gt 0 ]; then
    	CUR_Y=$(( "$CUR_Y" - ( "$OFFSET_Y" * 2 ) ))
	fi


    window_move "1 $GEOM_X $GEOM_Y $WINDOW_ID $CUR_X $CUR_Y $CUR_W $CUR_H"
    # if window_visible "$GEOM_X" "$GEOM_Y" "$CUR_X" "$CUR_Y" "$CUR_W" "$CUR_H"; then
    #     # xdotool windowraise "$WINDOW_ID"
    #     xprop -id "$WINDOW_ID" -f _CURTAIN_XYWH 8s -set _CURTAIN_XYWH ""
    # else
    #     xdotool windowminimize "$WINDOW_ID"
    #     xprop -id "$WINDOW_ID" -f _CURTAIN_XYWH 8s -set _CURTAIN_XYWH "$CUR_X $CUR_Y $CUR_W $CUR_H"
    # fi
}


function xdotool_getwindowgeometry_to_details() {
    cat /dev/stdin | sed 's/^ \+//' | awk -F '[ x,]' '$1 == "Window" { i=$2 } $1 == "Position:" { x=$2; y=$3 } $1 == "Geometry:" { w=$2; h=$3 } END { print x, y, w, h }'
}


function list_windows() {
    xdotool search --desktop "$(xdotool get_desktop)" --all .  2>/dev/null | grep '^[0-9]'
}


function xprop_details() {
    cat /dev/stdin | awk -F '=' 'NF < 2 { next } {printf("%s=", gensub(/^ *(.*[^ ])\(.*/, "\\1", "g", $1)) } $2 ~ /"/ { print gensub(/^ *"(.*)" *$/, "\\1", "g", $2); next } { print(gensub(/^ *(.*[^ ]) *$/, "\\1", "g", $2)) }'
}


function details_value {
    cat /dev/stdin | awk -v K="$1" -F '=' '$1 == K { print $2 }'
}


function xdotool_xprop_getwindowgeometry() {
    local XPROPS="$(xprop -id $1 | xprop_details)"
    local XPROP_MINIM="$(echo "$XPROPS" | details_value _NET_WM_STATE | awk 'BEGIN { m=0 } $0 ~ /_NET_WM_STATE_HIDDEN/ { m=1 } END { print m }' )"
    local XPROP_GEOM="$(echo "$XPROPS" | details_value _CURTAIN_XYWH)"
    if [ "$XPROP_MINIM" -gt 0 ] && [ ! -z "$XPROP_GEOM" ]; then
        echo $1 $XPROP_GEOM
        return 0
    fi
    local FRAME="$(xprop -id "$1" | grep _NET_FRAME_EXTENTS | awk -F [=,] '{print gensub(/.*([0-9]+), *([0-9]+), *([0-9]+), *([0-9]+).*/, "\\1 \\2 \\3 \\4", "g", $0)}')"
    local WIN="$(xdotool getwindowgeometry "$1" | xdotool_getwindowgeometry_to_details)"
    local FRAME_LRTB=( $FRAME )
    local WIN_XYWH=( $WIN )
    local X=$(( ${WIN_XYWH[0]} - (${FRAME_LRTB[0]} * 2) ))
    local Y=$(( ${WIN_XYWH[1]} - (${FRAME_LRTB[2]} * 2) ))
    local W=$(( ${WIN_XYWH[2]} + (${FRAME_LRTB[0]} + ${FRAME_LRTB[1]}) ))
    local H=$(( ${WIN_XYWH[3]} + (${FRAME_LRTB[2]} + ${FRAME_LRTB[3]}) ))
    echo "$1 $X $Y $W $H"
}


# function windows_in_column_slack() {
#     local CURRENT_COLUMN_WIDTH="$1"
#     local PERCENT="$2"
#     local PIXELS="$3"
#     local PER_VAL=$(( $CURRENT_COLUMN_WIDTH * (PERCENT / 100) ))
#     local PIX_VAL=$(( $CURRENT_COLUMN_WIDTH - $PIXELS ))
#     if [[ "$PER_VAL" -gt "$PIX_VAL" ]]; then
#         echo "$PER_VAL"
#         return
#     fi
#     echo "$PIX_VAL"
# }


function windows_in_column() {
    # export -f xdotool_xprop_getwindowgeometry
    # cat /dev/stdin | parallel xdotool_xprop_getwindowgeometry "$1"
    # echo "> $1, $2, $3"
    local SELECTED_WIN="$1"
    local SCREEN_TOP="$2"
    local SCREEN_HEIGHT="$3"

    cat /dev/stdin | \
        awk -v SELECTED_WIN="$SELECTED_WIN" '
            # Put the selected window at the top
            $1!=SELECTED_WIN { print NR, $0 }
            $1==SELECTED_WIN { FOUND=$0 }
            END {
                if (FOUND) {
                        print NR+1, FOUND
                }
            }
            ' | \
        sort -r | \
        sed 's/[0-9]\+ //' | \
        awk -v CENTER_OR_EDGE=1 -v SELECTED_WIN="$SELECTED_WIN" '
            BEGIN { COL_LEFT="UN"; COL_RIGHT="UN"; LEFT="UN"; ITEMS_INDEX=0  }

            function slack(WIDTH, SLACK_PIXELS, SLACK_PERCENT) {
                TMP = WIDTH * (SLACK_PERCENT / 100)
                if (TMP > SLACK_PIXELS) {
                    return SLACK_PIXELS
                }
                return TMP
            }

            # Output column details then windows in column, identified by current selected window (top).
            LEFT=="UN" {
                LEFT=$2
                WIDTH=$4
                RIGHT=$2+WIDTH
                COL_LEFT=LEFT
                COL_RIGHT=RIGHT
                COL_TOP=$3
                COL_BOT=$3+$5
                COL_HEIGHT=0
            }
            { ADD = 0 }
            CENTER_OR_EDGE == 0 {
                CENTER=$2 + ($4 / 2)
                if ((CENTER <= RIGHT) && (CENTER >= LEFT)) {
                    ADD = 1
                }
            }
            CENTER_OR_EDGE == 1 {
                LINE_LEFT=$2
                LINE_RIGHT=$2+$4
                INCLUDE_LEFT = LINE_LEFT + slack($4, 16, 16)
                INCLUDE_RIGHT = LINE_RIGHT - slack($4, 16, 16)
                if ((INCLUDE_LEFT < LEFT) && (INCLUDE_RIGHT < LEFT)) { next }
                if ((INCLUDE_LEFT > RIGHT) && (INCLUDE_RIGHT > RIGHT)) { next }
                ADD = 1
            }
            ADD == 1 {
                ITEMS[ITEMS_INDEX] = $0; ITEMS_INDEX = ITEMS_INDEX + 1
                if (COL_LEFT > $2) { COL_LEFT = $2 }
                if (COL_RIGHT < $2 + $4) { COL_RIGHT = $2 + $4 }
                if (($3 + $5) > COL_BOT) { COL_BOT = $3 + $5 }
                if ($3 < COL_TOP) { COL_TOP = $3 }
                COL_HEIGHT = COL_HEIGHT + $5
            }
            END {
                print SELECTED_WIN, COL_LEFT, COL_TOP, (COL_RIGHT - COL_LEFT), COL_HEIGHT
                for (I in ITEMS) {
                    print ITEMS[I]
                }
            }' | \
        awk -v SCREEN_TOP="$SCREEN_TOP" -v SCREEN_HEIGHT="$SCREEN_HEIGHT" '
            # Scale and force windows into the column (does make windows not overlap)
            NR == 1 {
                SELECTED_WIN = $1
                COL_LEFT = $2; COL_TOP = $3; COL_WIDTH = $4; COL_HEIGHT = $5
                SCREEN_OF_COL_FRACTION = SCREEN_HEIGHT / COL_HEIGHT
                # print "COL_HEIGHT=" COL_HEIGHT, "SCREEN_HEIGHT=" SCREEN_HEIGHT, COL_WIDTH
                SCREEN_BOT = SCREEN_TOP + SCREEN_HEIGHT
                SHIFT_SCREEN = SCREEN_TOP - COP_TOP
                # print "COL_TOP=", COL_TOP " COL_HEIGHT=", COL_HEIGHT
                next
            }
            {
                WIN_TOP = $3
                WIN_ACT_HEIGHT = $5
                if (WIN_ACT_HEIGHT > SCREEN_HEIGHT) { WIN_ACT_HEIGHT = SCREEN_HEIGHT }
                WIN_HEIGHT = int(SCREEN_HEIGHT / (COL_HEIGHT / WIN_ACT_HEIGHT))
                WIN_BOT = WIN_TOP + WIN_HEIGHT
                print $1, COL_LEFT, int(WIN_TOP + (WIN_HEIGHT / 2)), COL_WIDTH, WIN_HEIGHT
            }
            ' | \
            sort -n -k 3 | \
        awk -v SCREEN_TOP="$SCREEN_TOP" -v SCREEN_HEIGHT="$SCREEN_HEIGHT" '
            BEGIN { WIN_TOP=SCREEN_TOP }
            {
                print $1, $2, WIN_TOP, $4, $5
                WIN_TOP = WIN_TOP + $5
            }
            '
}

function test_windows_in_column() {
    cat /dev/stdin | windows_in_column "$1" "$2" "$3"
}


function test_build_spec() {
    build_spec $@
}


function test_identify_screen() {
    cat /dev/stdin | sed 's/ \+$//' | identify_screen
}


function test_xdotool_getwindowgeometry_to_details() {
    cat /dev/stdin | xdotool_getwindowgeometry_to_details
}


function test_xprop_details() {
    cat /dev/stdin | xprop_details
}


function pixelshift() {
    export -f xdotool_getwindowgeometry_to_details
    export -f xdotool_xprop_getwindowgeometry
    export -f xdotool_windowshift
    export -f xdotool_getdisplaygeometry
    export -f window_visible
    export -f details_value
    export -f xprop_details
    export -f window_move
    SHIFT_X="$1"
    SHIFT_Y="$2"
    list_windows | parallel xdotool_xprop_getwindowgeometry {} '|' parallel xdotool_windowshift "$SHIFT_X" "$SHIFT_Y" $(xdotool_getdisplaygeometry)
}


function window_move() {
    local SPLIT=( $@ )
    local MODE=${SPLIT[0]}
    local GEOM_X=${SPLIT[1]}
    local GEOM_Y=${SPLIT[2]}
    local WINDOW_ID=${SPLIT[3]}
    local X=${SPLIT[4]}
    local Y=${SPLIT[5]}
    local W=${SPLIT[6]}
    local H=${SPLIT[7]}
    echo "> $MODE $GEOM_X $GEOM_Y $WINDOW_ID $X $Y $W $H"

    local XPROPS="$(xprop -id $WINDOW_ID | xprop_details)"
    local XPROPS_FRAME="$(echo "$XPROPS" | details_value _NET_FRAME_EXTENTS | awk -F [=,] ' { print gensub(/.*([0-9]+), *([0-9]+), *([0-9]+), *([0-9]+).*/, "\\1 \\2 \\3 \\4", "g", $0) }')"

    # echo "XPROPS: $XPROPS"
    # echo "XPROPS_FRAME: $XPROPS_FRAME"
    local FRAME_LRTB=( $XPROPS_FRAME )
    X=$(( ${X} + ${FRAME_LRTB[0]} ))
    # Y=$(( ${Y} + ${FRAME_LRTB[2]} ))
    W=$(( ${W} - (${FRAME_LRTB[0]} + ${FRAME_LRTB[1]}) ))
    H=$(( ${H} - (${FRAME_LRTB[2]} + ${FRAME_LRTB[3]}) ))
    local XPROPS_COMPSITOR="$(echo "$XPROPS" | details_value _NET_WM_BYPASS_COMPOSITOR)"
    if [ "$XPROPS_COMPSITOR" == "2" ]; then
        # X=$(( $X - ${FRAME_LRTB[0]} ))
        # Y=$(( $Y - ${FRAME_LRTB[2]} ))
        printf "%s" ""
    fi
    if window_visible "$GEOM_X" "$GEOM_Y" "$X" "$Y" "$W" "$H"; then
        if [ "$MODE" -eq 2 ] || [ "$MODE" -eq 3 ]; then
            xdotool windowsize "$WINDOW_ID" "$W" "$H"
        fi
        if [ "$MODE" -eq 1 ] || [ "$MODE" -eq 3 ]; then
            xdotool windowmove "$WINDOW_ID" "$X" "$Y"
        fi
        local WINDOW_IS_MINIMIZED="$(echo "$XPROPS" | details_value _NET_WM_STATE | awk 'BEGIN { m=0 } $0 ~ /_NET_WM_STATE_HIDDEN/ { m=1 } END { print m }' )"
        if [ "$WINDOW_IS_MINIMIZED" -gt 0 ]; then
            xdotool windowactivate "$WINDOW_ID"
        fi
        xprop -id "$WINDOW_ID" -f _CURTAIN_XYWH 8s -set _CURTAIN_XYWH ""
        # xdotool windowactivate "$WINDOW_ID"
    else
        xdotool windowminimize "$WINDOW_ID"
        # TODO: Do setting respect mode perhaps
        xprop -id "$WINDOW_ID" -f _CURTAIN_XYWH 8s -set _CURTAIN_XYWH "$X $Y $W $H"
    fi

}


if [ ! -z "$ACTION_TEST" ]; then
    shift $(( OPTIND - 1 ))
    test_"$ACTION_TEST" $@
fi


if [ ! -z "$PIXELSHIFT" ]; then
    ACTIVE_WINDOW="$(xdotool getactivewindow)"
    shift 1
    pixelshift "$PIXELSHIFT" 0
    xdotool windowactivate "$ACTIVE_WINDOW"
fi


if [ ! -z "$CENTER" ]; then
    shift 1
    echo "HERE"
    xdotool_xprop_getwindowgeometry "$(xdotool getactivewindow)"
    S_WIN_GEOM="$(xdotool_xprop_getwindowgeometry "$(xdotool getactivewindow)")"
    echo "> $S_WIN_GEOM"
    S_DISP_GEOM="$(xdotool_getdisplaygeometry)"
    WIN_GEOM=( $S_WIN_GEOM )
    DISP_GEOM=( $S_DISP_GEOM )
    XSHIFT=$(( (${DISP_GEOM[0]} / 2) - (${WIN_GEOM[1]} + (${WIN_GEOM[3]} / 2))  ))
    ACTIVE_WINDOW="$(xdotool getactivewindow)"
    pixelshift "$XSHIFT" 0
    xdotool windowactivate "$ACTIVE_WINDOW"
fi

if [ ! -z "$COLUMN" ]; then
    export -f details_value
    export -f window_visible
    export -f window_move
    export -f xprop_details
    export -f xdotool_xprop_getwindowgeometry
    export -f xdotool_getwindowgeometry_to_details
    ACTIVE_WINDOW="$(xdotool getactivewindow)"
    WINDOW_ID="$(xdotool getactivewindow)"
    DISP_GEOM="$(xdotool_getdisplaygeometry)"
    S_DISP_HEIGHT="$(echo "$DISP_GEOM" | sed 's/.* //')"
    Y_MIN="$(echo "$Y_DIRECTION_BUFFER" | sed 's/ .*//')"
    Y_MAX="$(echo "$Y_DIRECTION_BUFFER" | sed 's/.* //')"
    Y_HEIGHT=$(( $S_DISP_HEIGHT - ($Y_MIN + $Y_MAX)))
    if [ ! -z "$SELECTED_WINDOW_ID" ]; then
        WINDOW_ID="$SELECTED_WINDOW_ID"
    fi
    list_windows | parallel xdotool_xprop_getwindowgeometry {} | windows_in_column "$WINDOW_ID" $Y_MIN $Y_HEIGHT | parallel window_move "3 $DISP_GEOM {}"
    # xdotool windowactivate "$ACTIVE_WINDOW"
fi


function win_in_dir() {
    local DIR="$1"
    export -f details_value
    export -f window_visible
    export -f window_move
    export -f xprop_details
    export -f xdotool_xprop_getwindowgeometry
    export -f xdotool_getwindowgeometry_to_details
    DISP_GEOM="$(xdotool_getdisplaygeometry)"
    S_DISP_HEIGHT="$(echo "$DISP_GEOM" | sed 's/.* //')"
    Y_MIN="$(echo "$Y_DIRECTION_BUFFER" | sed 's/ .*//')"
    Y_MAX="$(echo "$Y_DIRECTION_BUFFER" | sed 's/.* //')"
    Y_HEIGHT=$(( $S_DISP_HEIGHT - ($Y_MIN + $Y_MAX)))
    ACTIVE_WINDOW="$(xdotool getactivewindow)"
    WINDOWS="$( list_windows | parallel xdotool_xprop_getwindowgeometry {} )"
    COL_WINS="$( echo "$WINDOWS" | windows_in_column "$ACTIVE_WINDOW" $Y_MIN $Y_HEIGHT)"
    if [ "$DIR" == 'j' ] || [ "$DIR" == 'k' ]; then
        VERT="$(printf "%s" "$COL_WINS" | awk -v ACTIVE="$ACTIVE_WINDOW" 'BEGIN { PREV="_"; NEXT="_"; WAS=0 }
            $1 == ACTIVE { WAS = 1; next }
            WAS == 0 { PREV=$0 }
            WAS == 1 {
                NEXT = $0
                WAS = 2
            }
            END { print PREV "/" NEXT }
            ')"
        if [ "$DIR" == "j" ]; then
            echo "$VERT" | sed 's^.*/^^'
            return
        fi
        echo "$VERT" | sed 's^/.*^^'
        return
    else
        ACT_MID="$(printf "%s" "$WINDOWS" | awk -v W="$ACTIVE_WINDOW" 'W==$1 { print int($2 + ($4 / 2)), int($3 + ($5 / 2)) }')"
        ACT_MID_X="$( echo "$ACT_MID" | sed 's/ .*//')"
        ACT_MID_Y="$( echo "$ACT_MID" | sed 's/.* //')"
        TARGET_WINDOW="$(
            printf "%s\n%s" "$(echo "$COL_WINS" | sed 's/^/ACTCOL /')" "$WINDOWS" \ |
                awk -v DIR="$DIR" -v ACT_MID_X="$ACT_MID_X" -v ACT_MID_Y="$ACT_MID_Y" 'BEGIN {ARLEN=0; DST=999999; WIN=""}

                    function abs(v) {return v < 0 ? -v : v}

                    # Keep a note of items in current column
                    $1 == "ACTCOL" { AR[ARLEN++] = $2; next }

                    # Remove items in current column
                    {
                        for (i=0; i<ARLEN; i++) {
                            if (AR[i] == $1) {
                                next
                            }
                        }
                    }

                    # Remove windows that are in the wrong direction
                    DIR=="h" && ($2 + $4) > ACT_MID_X { next }
                    DIR=="l" && $2 < ACT_MID_X { next }

                    {
                        CUR_MID_X = int($2 + ($4 / 2));
                        CUR_MID_Y = int($3 + ($5 / 2));
                        X_DIST = abs(ACT_MID_X - CUR_MID_X);
                        Y_DIST = abs(ACT_MID_Y - CUR_MID_Y);
                        CUR_DIST = sqrt((X_DIST * X_DIST) + (Y_DIST * Y_DIST));
                        # print "WIN: ", $1
                        if (CUR_DIST < DST) {
                            # print "CUR_MID_X=", CUR_MID_X;
                            # print "CUR_MID_Y=", CUR_MID_Y;
                            # print "ACT_MID_X=", ACT_MID_X;
                            # print "ACT_MID_Y=", ACT_MID_Y;
                            # print "CUR_DIST=", CUR_DIST;
                            DST = CUR_DIST;
                            WIN = $0
                        }
                    }

                    END {
                        if (WIN != "") {
                            print WIN
                        }
                    }
                    '
            )"
        if [ ! -z "$TARGET_WINDOW" ]; then
            printf "%s\n" "$TARGET_WINDOW"
        fi
    fi
}

if [ ! -z "$DIR" ]; then
    DISP_GEOM="$(xdotool_getdisplaygeometry)"
    S_DISP_WIDTH="$(echo "$DISP_GEOM" | sed 's/ .*//')"
    TARGET_WINDOW="$( win_in_dir "$DIR" )"
    LEFT="$( echo "$TARGET_WINDOW" | awk '{ print $2 }' )"
    SHIFT="$( echo "$DISP_GEOM $TARGET_WINDOW" | awk '
        $4 < 0 { print 0 - $4; next }
        ($4 + $6) > $1 { print "-" ($4 + $6) - $1 }
        ' )"
    if [ "$SHIFT" != "0" ]; then
        $0 -s "$SHIFT"
    fi
    if [ ! -z "$TARGET_WINDOW" ]; then
        xdotool windowactivate "$(echo "$TARGET_WINDOW" | sed 's/ .*//')"
    fi
fi


if [ ! -z "$SWAP" ]; then
    export -f window_visible
    export -f window_move
    export -f details_value
    export -f xprop_details
    DISP_GEOM="$(xdotool_getdisplaygeometry)"
    ACTIVE_WIN="$(xdotool_xprop_getwindowgeometry "$(xdotool getactivewindow)")"
    TARGET_WINDOW="$( win_in_dir "$SWAP" )"
    MOVES="$(
        printf "%s\n%s\n" "$ACTIVE_WIN" "$TARGET_WINDOW" | \
            awk '
                BEGIN { FIRST_ID=""; SECOND_ID=""; FIRST=""; SECOND=""; }
                FIRST_ID != "" { SECOND_ID = $1; SECOND = $2 " " $3 " " $4 " " $5 }
                FIRST == "" { FIRST_ID = $1; FIRST = $2 " " $3 " " $4 " " $5 }
                END {
                    print SECOND_ID, FIRST
                    print FIRST_ID, SECOND
                }
                ' | \
            sed 's/^//'
        )"

    printf "%s\n" "$MOVES" | sed 's/^/3 '"$DISP_GEOM /" | parallel window_move {}
fi


if [ ! -z "$MOVE" ]; then

    if [ "$MOVE" == "j" ] || [ "$MOVE" == "k" ]; then
        "$0" -w "$MOVE"
        exit
    fi

    export -f details_value
    export -f window_visible
    export -f window_move
    export -f xprop_details
    export -f xdotool_xprop_getwindowgeometry
    export -f xdotool_getwindowgeometry_to_details

    DISP_GEOM="$(xdotool_getdisplaygeometry)"
    S_DISP_HEIGHT="$(echo "$DISP_GEOM" | sed 's/.* //')"
    Y_MIN="$(echo "$Y_DIRECTION_BUFFER" | sed 's/ .*//')"
    Y_MAX="$(echo "$Y_DIRECTION_BUFFER" | sed 's/.* //')"
    Y_HEIGHT=$(( $S_DISP_HEIGHT - ($Y_MIN + $Y_MAX)))

    ACTIVE_WINDOW="$(xdotool getactivewindow)"
    WINDOWS="$( list_windows | parallel xdotool_xprop_getwindowgeometry {} )"
    COL_WINS="$( echo "$WINDOWS" | windows_in_column "$ACTIVE_WINDOW" $Y_MIN $Y_HEIGHT)"
    WIN_IN_COL_COUNT="$(echo "$COL_WINS" | wc -l)"

    if [ "$WIN_IN_COL_COUNT" -gt 1 ]; then
        MOVE_X_FROM="$( echo "$COL_WINS" | awk '{ print $2 }' | tail -n 1 )"
        MOVE_DISTANCE="$( echo "$COL_WINS" | head -n 1 | awk '{ print $4 }' )"
        echo $MOVE_DISTANCE

        NEGATE=""
        if [ "$MOVE" == "l" ]; then
            NEGATE="-"
        fi
        MOVE_WINDOWS="$(
            echo "$WINDOWS" | \
            awk -v MOVE_X_FROM="$MOVE_X_FROM" \
                -v MOVE_DISTANCE="${NEGATE}$MOVE_DISTANCE" \
                -v ACTIVE_WINDOW="$ACTIVE_WINDOW" \
                '
                    $1 == ACTIVE_WINDOW { next }
                    ($2 >= MOVE_X_FROM) && (MOVE_DISTANCE > 0) { print $1, $2 + MOVE_DISTANCE, $3, $4, $5 }
                    ($2 <= MOVE_X_FROM) && (MOVE_DISTANCE < 0) { print $1, $2 + MOVE_DISTANCE, $3, $4, $5 }
                ' | \
            sed 's/^/3 '"$DISP_GEOM /"
            )"
        printf "%s" "$MOVE_WINDOWS" | parallel window_move {}
        MOVED_FROM_WINDOW_ID="$( echo "$COL_WINS" | awk -v ACTIVE_WINDOW="$ACTIVE_WINDOW" '$1 != ACTIVE_WINDOW { print $1 }' )"
        printf "%s\n%s\n"  "$MOVED_FROM_WINDOW_ID" "$ACTIVE_WINDOW"| parallel -j 1 $0 -o -i {}
        exit
    else
        TARGET_WINDOW="$( win_in_dir "$MOVE" )"
        echo "$TARGET_WINDOW"
        echo $ACTIVE_WINDOW
        MOVE_TO_COL_WINS="$( echo "$WINDOWS" | windows_in_column "$(echo "$TARGET_WINDOW" | sed 's/ .*//')" $Y_MIN $Y_HEIGHT)"
        echo "$MOVE_TO_COL_WINS"
        MOVE_TO_COL_COUNT="$( echo "$MOVE_TO_COL_WINS" | wc -l )"
        echo $MOVE_TO_COL_COUNT
        echo $Y_HEIGHT
        echo "="
        OLD_WINDOW_MOVE="$(
            printf "%s" "$MOVE_TO_COL_WINS" | awk \
                -v WINDOW_COUNT="$MOVE_TO_COL_COUNT" \
                -v DISP_GEOM="$DISP_GEOM" '
                    BEGIN { MULT = WINDOW_COUNT / (WINDOW_COUNT + 1) }
                    {
                        # print $0
                        print 3, DISP_GEOM, $1, $2, int($3 * MULT), $4, int($5 * MULT)
                    }
                ' )"
        OLD_WINDOW_MOVE_NEW_Y="$(
            printf "%s" "$OLD_WINDOW_MOVE" | awk '
                BEGIN { Y=0; H=0 }
                $6 > Y { Y = $6; H = $8 }
                END { print Y + H + 1 }' )"
        OLD_WINDOW_MOVE_NEW_H=$(( $Y_HEIGHT - $OLD_WINDOW_MOVE_NEW_Y ))
        CURRENT_WINDOW_NEW_POSITION="$(
            echo "$OLD_WINDOW_MOVE" | \
                head -n 1 | \
                awk -v ACTIVE_WINDOW="$ACTIVE_WINDOW" \
                    -v Y="$OLD_WINDOW_MOVE_NEW_Y" \
                    -v H="$OLD_WINDOW_MOVE_NEW_H" '
                        { print $1, $2, $3, ACTIVE_WINDOW, $5, Y, $7, H }'
            )"
        printf "%s\n%s\n" "$OLD_WINDOW_MOVE" "$CURRENT_WINDOW_NEW_POSITION" | parallel window_move {}

        # 52428802 1169 0 1466 1541
        # 138412039 1169 1541 1466 616

    fi

fi


if [ ! -z "$WINMOVE" ]; then
    XX="$(echo "$WINMOVE" | awk -F 'x' '{ print $1 }')"
    YY="$(echo "$WINMOVE" | awk -F 'x' '{ print $2 }')"
    WW="$(echo "$WINMOVE" | awk -F 'x' '{ print $3 }')"
    HH="$(echo "$WINMOVE" | awk -F 'x' '{ print $4 }')"
    DISP_GEOM="$(xdotool_getdisplaygeometry)"
    PARAM="$(echo "$(xdotool getactivewindow) $XX $YY $WW $HH" | sed 's/^/3 '"$DISP_GEOM /")"
    window_move "$PARAM"
fi


if [ ! -z "$REPORT" ]; then
    WIN="$(xdotool getactivewindow)"
    xdotool_xprop_getwindowgeometry "$WIN"
fi


if [ ! -z "$GAP" ]; then
    export -f details_value
    export -f window_visible
    export -f window_move
    export -f xprop_details
    export -f xdotool_xprop_getwindowgeometry
    export -f xdotool_getwindowgeometry_to_details
    DISP_GEOM="$(xdotool_getdisplaygeometry)"
    S_DISP_HEIGHT="$(echo "$DISP_GEOM" | sed 's/.* //')"
    Y_MIN="$(echo "$Y_DIRECTION_BUFFER" | sed 's/ .*//')"
    Y_MAX="$(echo "$Y_DIRECTION_BUFFER" | sed 's/.* //')"
    Y_HEIGHT=$(( $S_DISP_HEIGHT - ($Y_MIN + $Y_MAX)))
    ACTIVE_WINDOW="$(xdotool getactivewindow)"
    WINDOWS="$( list_windows | parallel xdotool_xprop_getwindowgeometry {} )"
    COL_WINS="$( echo "$WINDOWS" | windows_in_column "$ACTIVE_WINDOW" $Y_MIN $Y_HEIGHT)"

    COL_LEFT_RIGHT="$(printf "%s\n" "$COL_WINS" | head -n1 | awk '
        BEGIN { WR = 1; WL = 999999 }
        { if ($2 + $4 > WR) { WR = $2 + $4 } if (WL > $2) { WL = $2 } }
        END { print WL, WR }')"

    COL_LEFT="$(echo "$COL_LEFT_RIGHT" | sed 's/ .*//')"
    COL_RIGHT="$(echo "$COL_LEFT_RIGHT" | sed 's/.* //')"

    GAP_LEFT_RIGHT="$(printf "%s\n" "$WINDOWS" | awk -v COL_LEFT="$COL_LEFT" -v COL_RIGHT="$COL_RIGHT" '
        BEGIN { MOST_LEFT=0; MOST_RIGHT=999999 }
        (($2 + $4 > MOST_LEFT) && ($2 + $4 < COL_LEFT)) {
                MOST_LEFT = $2 + $4
        }
        (($2 < MOST_RIGHT) && ($2 > COL_RIGHT)) {
                MOST_RIGHT = $2
        }
        END { print COL_LEFT - MOST_LEFT, MOST_RIGHT - COL_RIGHT }')"

    GAP_LEFT="$(echo "$GAP_LEFT_RIGHT" | sed 's/ .*//')"
    GAP_RIGHT="$(echo "$GAP_LEFT_RIGHT" | sed 's/.* //')"

    MOVES="$(
        printf "%s\n" "$WINDOWS" | awk -v GAP_LEFT="$GAP_LEFT" -v GAP_RIGHT="$GAP_RIGHT" -v COL_LEFT="$COL_LEFT" -v COL_RIGHT="$COL_RIGHT" '
            $2 + $4 < COL_LEFT {
                print $1, ($2 + GAP_LEFT) - 1, $3, $4, $5
            }
            $2 > COL_RIGHT {
                print $1, ($2 - GAP_RIGHT) + 1, $3, $4, $5
            }'
        )"

    printf "%s\n" "$MOVES" | sed 's/^/1 '"$DISP_GEOM /" | parallel window_move {}


    #window_move "1 $GEOM_X $GEOM_Y $WINDOW_ID $CUR_X $CUR_Y $CUR_W $CUR_H"
    xdotool windowactivate "$ACTIVE_WINDOW"
fi
